"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.withResponsesWebSocketSession = withResponsesWebSocketSession;
const agents_core_1 = require("@openai/agents-core");
const openaiProvider_1 = require("./openaiProvider.js");
function attachCleanupErrorToThrownError(callbackError, cleanupError) {
    if (!(callbackError instanceof Error)) {
        return;
    }
    const callbackErrorWithMetadata = callbackError;
    if (typeof callbackErrorWithMetadata.cause === 'undefined') {
        callbackErrorWithMetadata.cause = cleanupError;
        return;
    }
    callbackErrorWithMetadata.cleanupError = cleanupError;
}
/**
 * Runs a callback within a session-scoped Responses API websocket provider/runner and closes the
 * provider afterwards so websocket connections do not keep the process alive.
 */
async function withResponsesWebSocketSession(callback, options = {}) {
    const provider = new openaiProvider_1.OpenAIProvider({
        ...(options.providerOptions ?? {}),
        useResponses: true,
        useResponsesWebSocket: true,
    });
    const runner = new agents_core_1.Runner({
        ...(options.runnerConfig ?? {}),
        modelProvider: provider,
    });
    const run = runner.run.bind(runner);
    let callbackFailed = false;
    let callbackError;
    let callbackResult;
    try {
        callbackResult = await callback({ provider, runner, run });
    }
    catch (error) {
        callbackFailed = true;
        callbackError = error;
    }
    try {
        await provider.close();
    }
    catch (closeError) {
        if (!callbackFailed) {
            throw closeError;
        }
        attachCleanupErrorToThrownError(callbackError, closeError);
    }
    if (callbackFailed) {
        throw callbackError;
    }
    return callbackResult;
}
//# sourceMappingURL=responsesWebSocketSession.js.map